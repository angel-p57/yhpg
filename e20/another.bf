** ported from "another_rb"
** input: each case ( "SG" ) for each line **
** output: each solution for each line **

* main loop ( one char read ahead )
,+[-
 * sliding loop ( 2 times )
 <++[-
  * parse one char and convert to a path expression of the node
  >>++++++[-<-------->]+<[-[-[-[-[-[-[-[-[-[--------[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-[-
    > ->> *Z:00010    * >>>>>>>>>+>>>>>>-<<<<<<<<<<<<<<< <<
  <]>[->> *Y:0001     * >>>>>>>>>+>>>-<<<<<<<<<<<< <<]
  <]>[->> *X:001000000* >>>>>>+>>>>>>>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *W:00100010 * >>>>>>+>>>>>>>>>>>>+>>>>>>-<<<<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *V:0010001  * >>>>>>+>>>>>>>>>>>>+>>>-<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *U:00100011 * >>>>>>+>>>>>>>>>>>>+>>>+>>>-<<<<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *T:0000     * >>>>>>>>>>>>-<<<<<<<<<<<< <<]
  <]>[->> *S:000      * >>>>>>>>>-<<<<<<<<< <<]
  <]>[->> *R:00100000 * >>>>>>+>>>>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *Q:0010000  * >>>>>>+>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *P:001000   * >>>>>>+>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *O:110000010* +>>>+>>>>>>>>>>>>>>>>>>+>>>>>>-<<<<<<<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *N:00000    * >>>>>>>>>>>>>>>-<<<<<<<<<<<<<<< <<]
  <]>[->> *M:00       * >>>>>>-<<<<<< <<]
  <]>[->> *L:001      * >>>>>>+>>>-<<<<<<<<< <<]
  <]>[->> *K:0010     * >>>>>>+>>>>>>-<<<<<<<<<<<< <<]
  <]>[->> *J:00100    * >>>>>>+>>>>>>>>>-<<<<<<<<<<<<<<< <<]
  <]>[->> *I:11000001 * +>>>+>>>>>>>>>>>>>>>>>>+>>>-<<<<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *H:000000   * >>>>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *G:0        * >>>-<<< <<]
  <]>[->> *F:         * - <<]
  <]>[->> *E:00101    * >>>>>>+>>>>>>+>>>-<<<<<<<<<<<<<<< <<]
  <]>[->> *D:11000000 * +>>>+>>>>>>>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *C:1100000  * +>>>+>>>>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *B:12000    * +>>>++>>>>>>>>>>>>-<<<<<<<<<<<<<<< <<]
  <]>[->> *A:10       * +>>>>>>-<<<<<< <<]
  <]>[->> *9:1        * +>>>-<<< <<]
  <]>[->> *8:11       * +>>>+>>>-<<<<<< <<]
  <]>[->> *7:110      * +>>>+>>>>>>-<<<<<<<<< <<]
  <]>[->> *6:110000   * +>>>+>>>>>>>>>>>>>>>-<<<<<<<<<<<<<<<<<< <<]
  <]>[->> *5:1200     * +>>>++>>>>>>>>>-<<<<<<<<<<<< <<]
  <]>[->> *4:120      * +>>>++>>>>>>-<<<<<<<<< <<]
  <]>[->> *3:12       * +>>>++>>>-<<<<<< <<]
  <]>[->> *2:121      * +>>>++>>>+>>>-<<<<<<<<< <<]
  <]>[->> *1:1100     * +>>>+>>>>>>>>>-<<<<<<<<<<<< <<]
  <]>[->> *0:11000    * +>>>+>>>>>>>>>>>>-<<<<<<<<<<<<<<< <<]
 <<[->+<]>>,<]
 * create an anchor ( only for debug purpose )
 <<<-
 * clear a newline or eof
 >>>>+[-]
 * loop for searching a forked point or an end of the paths
 +[
  >+>+[
   * not the end in the path of the goal node
   <[
    * not the end in the path of the start node
    [->-<]
    >[
     * detect a forked point ( stop this loop )
     +++<+<-
    ]
    <<[-
     * not a forked point ( slide and continue this loop )
     >>>+<<
    ]
   ]
   >[<<-<]
  ]
  <<[-<<<]
 >>>]
 * count the distance between the forked point and the end of the path of the goal node
>->[>>>+]<<<[[-]>[-<<<+>>>]<<<+<]
 * count and add the distance between the forked point and the end of the path of start node
 >>+[[-]<[->>>+<<<]>>>+>+]
 * print as decimal
 <+[>[+>>>]<[>--------->+>]<<<-]
 ->+++++++++>-[>]
 <+[-
  >++++++[-<++++++++>]
  <.[-]
 <+]
 * back to the anchor and print a newline
 +[-<+]>++++++++++.
,+]
